<?php

/**
 * @file
 * Integrates the PayPoint payment processing service with Ubercart.
 */

/**
 * Implementation of hook_menu().
 */
function uc_paypoint_menu() {
  $items['admin/store/orders/%uc_order/paypoint'] = array(
    'title' => 'Paypoint payment: Order @order_id',
    'title arguments' => array('@order_id' => arg(3)),
    'description' => 'Payppoint payment form on the order page.',
    'page callback' => 'uc_paypoint_terminal',
    'page arguments' => array(3),
    'access arguments' => array('process paypoint'),
    'file' => 'uc_paypoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function uc_paypoint_perm() {
  return array('administer paypoint', 'process paypoint', 'view paypoint credit card numbers');
}

/**
 * Implementation of hook_payment_method().
 */
function uc_paypoint_payment_method() {
  $cards = theme('uc_paypoint_cards');
  $logo = theme('uc_paypoint_logo');
  $methods[] = array(
    'id' => 'paypoint',
    'name' => t('PayPoint'),
    'title' => $logo . t('PayPoint') . $cards,
    'review' => t('PayPoint'),
    'desc' => t('Redirect users to submit payments through PayPoint.'),
    'callback' => 'uc_payment_method_paypoint',
    'weight' => 1,
    'checkout' => FALSE,
    'no_gateway' => TRUE,
  );
  return $methods;
}

/**
 * Implementation of hook_theme().
 */
function uc_paypoint_theme() {
  return array(
    'uc_paypoint_cards' => array(
      'arguments' => array(),
      'file' => 'uc_paypoint.theme.inc',
    ),
    'uc_paypoint_logo' => array(
      'arguments' => array(),
      'file' => 'uc_paypoint.theme.inc',
    ),
  );
}

/**
 * Callback function for the PayPoint payment method.
 */
function uc_payment_method_paypoint($op, &$arg1) {
  $trans_id = $arg1->order_id;
  if (empty($trans_id)) {
    $trans_id = t('Unknown');
  }
  switch ($op) {
    case 'cart-details':
      $details = drupal_get_form('uc_paypoint_credit_form', $arg1);
      return uc_strip_form($details);
    case 'cart-review':
      $review[] = array('title' => t('Card Type'), 'data' => check_plain($arg1->payment_details['cc_type']));
      $review[] = array('title' => t('Card Owner'), 'data' => check_plain($arg1->payment_details['cc_owner']));
      $review[] = array('title' => t('Card Number'), 'data' => uc_credit_display_number($arg1->payment_details['cc_number']));
      $start = $arg1->payment_details['cc_start_month'] . '/' . $arg1->payment_details['cc_start_year'];
      $review[] = array('title' => t('Start Date'), 'data' => strlen($start) > 1 ? $start : '');
      $review[] = array('title' => t('Expiration'), 'data' => $arg1->payment_details['cc_exp_month'] .'/'. $arg1->payment_details['cc_exp_year']);
      $review[] = array('title' => t('Issue Number'), 'data' => user_access('view cc numbers') ? $arg1->payment_details['cc_issue'] : str_repeat('-', strlen($arg1->payment_details['cc_issue'])));
      $review[] = array('title' => t('CVV'), 'data' => user_access('view cc numbers') ? $arg1->payment_details['cc_cvv'] : str_repeat('-', strlen($arg1->payment_details['cc_cvv'])));
      return $review;
    case 'edit-process':
      $cache = uc_credit_cache('load');

      $changes['payment_details']['cc_type'] = check_plain($_POST['cc_type']);
      $changes['payment_details']['cc_owner'] = check_plain($_POST['cc_owner']);
      if (strpos($_POST['cc_number'], t('(Last 4) ')) !== 0) {
        $changes['payment_details']['cc_number'] = check_plain($_POST['cc_number']);
      }
      else {
        $changes['payment_details']['cc_number'] = $cache['cc_number'];
      }
      $changes['payment_details']['cc_exp_month'] = check_plain($_POST['cc_exp_month']);
      $changes['payment_details']['cc_exp_year'] = check_plain($_POST['cc_exp_year']);
      if ($_POST['cc_cvv'] !== str_repeat('-', strlen($_POST['cc_cvv']))) {
        $changes['payment_details']['cc_cvv'] = check_plain($_POST['cc_cvv']);
      }
      else {
        $changes['payment_details']['cc_cvv'] = $cache['cc_cvv'];
      }
      return $changes;
    case 'order-view':
      $output =  t('Transaction ID: @trans_id', array('@trans_id' => $trans_id));
//      if (user_access('process papypoint') && is_numeric($trans_id) && !_uc_paypoint_order_empty($arg1)) { TODO
      if (user_access('process papypoint') && is_numeric($trans_id)) {
        $output .= '<br />' . l(t('PayPoint terminal'), 'admin/store/orders/'. $trans_id .'/paypoint');
      }
      else {
        $output .= '<br />' . t('Make sure to fill all the order details in order to process payments.');
      }
      return $output;
    case 'cart-process':
      // Unfortunately submit handlers on the checkout form do not handle the credit card details, so
      // we are forced to look at the POST directly. Very similar to uc_credit.

      $paypoint_cc_data = array(
        'cc_type' => check_plain($_POST['cc_type']),
        'cc_owner' => check_plain($_POST['cc_owner']),
        'cc_number' => check_plain(str_replace(' ', '',  $_POST['cc_number'])),
        'cc_start_month' => check_plain($_POST['cc_start_month']),
        'cc_start_year' => check_plain($_POST['cc_start_year']),
        'cc_exp_month' => check_plain($_POST['cc_exp_month']),
        'cc_exp_year' => check_plain($_POST['cc_exp_year']),
        'cc_issue' => check_plain($_POST['cc_issue']),
        'cc_cvv' => check_plain($_POST['cc_cvv']),
      );

      // Recover cached CC data in $_POST if it exists, this comes from the form itself.
      if (isset($_POST['payment_details_data'])) {
        $cache = uc_credit_cache('save', $_POST['payment_details_data']);
      }

      // Account for partial CC numbers when masked by the system.
      if (substr($paypoint_cc_data['cc_number'], 0, strlen(t('(Last4)'))) == t('(Last4)')) {
        // Recover the number from the encrypted data in $_POST if truncated.
        if (isset($cache['cc_number'])) {
          $paypoint_cc_data['cc_number'] = $cache['cc_number'];
        }
        else {
          $paypoint_cc_data['cc_number'] = '';
        }
      }

      // Account for masked CVV numbers.
      if (!empty($paypoint_cc_data['cc_cvv']) && $paypoint_cc_data['cc_cvv'] == str_repeat('-', strlen($paypoint_cc_data['cc_cvv']))) {
        // Recover the number from the encrypted data in $_POST if truncated.
        if (isset($cache['cc_cvv'])) {
          $paypoint_cc_data['cc_cvv'] = $cache['cc_cvv'];
        }
        else {
          $paypoint_cc_data['cc_cvv'] = '';
        }
      }

      $arg1->payment_details = $paypoint_cc_data;
      $return = uc_paypoint_card_validate($paypoint_cc_data);

      // Initialize the encryption key and class.
      $key = uc_credit_encryption_key();
      $crypt = new uc_encryption_class;

      // Store the encrypted details in the session for the next pageload.
      $_SESSION['paypoint_crd'] = $crypt->encrypt($key, serialize($arg1->payment_details));

      // Log any errors to the watchdog.
      uc_store_encryption_errors($crypt, 'uc_credit');

      // If we're going to the review screen and no errors detected,
      // set a variable that lets us know we're paying by PayPoint and credit card.
      if ($return) {
        $_SESSION['uc_paypoint_cc_pay'] = TRUE;
      }

      return $return;
    case 'order-details':
//      if (is_numeric($trans_id) && !_uc_paypoint_order_empty($arg1)) {
      if (is_numeric($trans_id)) {
        $output = t('Use the !link to process PayPoint payments.', array('!link' => l(t('PayPoint terminal'), 'admin/store/orders/' . $trans_id . '/paypoint')));
      }
      else {
        $output = t('Complete the order details in order to process payments.');
      }
      return $output;
    case 'settings':
      return uc_paypoint_settings_form();
  }
}

/**
 * Perform a custom validation on a bunch of card details.
 */
function uc_paypoint_card_validate($card_data) {
  $return = TRUE;
  // Make sure an owner value was entered.
  if (empty($card_data['cc_owner'])) {
    drupal_set_message(t('Enter the owner name as it appears on the card.'), 'error');
    $return = FALSE;
  }

  // Validate the CC number if that's turned on/check for non-digits.
  if (!_valid_card_number($card_data['cc_number']) || !ctype_digit($card_data['cc_number'])) {
    drupal_set_message(t('You have entered an invalid credit card number.'), 'error');
    $return = FALSE;
  }

  // Validate the start date (if entered).
  if (!_valid_card_start($card_data['cc_start_month'], $card_data['cc_start_year'])) {
    drupal_set_message(t('The start date you entered is invalid.'), 'error');
    $return = FALSE;
  }

  // Validate the card expiration date.
  if (!_valid_card_expiration($card_data['cc_exp_month'], $card_data['cc_exp_year'])) {
    drupal_set_message(t('The credit card you entered has expired.'), 'error');
    $return = FALSE;
  }

  // Validate the issue number (if entered).  With issue numbers, '01' is
  // different from '1', but is_numeric() is still appropriate.
  if (!_valid_card_issue($card_data['cc_issue'])) {
    drupal_set_message(t('The issue number you entered is invalid.'), 'error');
    $return = FALSE;
  }

  // Validate the CVV number if enabled.
  if (!_valid_cvv($card_data['cc_cvv'])) {
    drupal_set_message(t('You have entered an invalid CVV number.'), 'error');
    $return = FALSE;
  }

  return $return;
}

/**
 * Settings form for the PayPoint payment method.
 */
function uc_paypoint_settings_form() {
  $form['uc_paypoint_merchant'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPoint merchant ID'),
    '#description' => t('Your unique PayPoint merchant account number given to you when you registered with PayPoint.'),
    '#default_value' => variable_get('uc_paypoint_merchant', 'secpay'),
  );
  $form['uc_paypoint_vpn'] = array(
    '#type' => 'textfield',
    '#title' => t('VPN Password'),
    '#description' => t('Your VPN password can be set from within the !paypoint Merchant Extranet. (Click on "Account" then "Remote Passwords" and select VPN from the drop down list).', array('!paypoint' => l(t('Merchant Extranet'), 'https://www.paypoint.net/secnet/app', array('absolute' => TRUE)))),
    '#default_value' => variable_get('uc_paypoint_vpn', 'secpay'),
  );
  $form['uc_paypoint_currency'] = array(
    '#type' => 'select',
    '#title' => t('Currency code'),
    '#description' => t('Transactions can only be processed in one of the listed currencies.'),
    '#options' => _uc_paypoint_currency_codes(),
    '#default_value' => variable_get('uc_paypoint_currency', 'GBP'),
  );
  $credit_cards = _uc_paypoint_credit_cards();
  $form['uc_paypoint_credit_cards'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed credit cards'),
    '#description' => t('Select which credit cards can be selected by the users when making the payments.'),
    '#options' => $credit_cards,
    '#default_value' => variable_get('uc_paypoint_credit_cards', array_keys($credit_cards)),
  );
  $form['uc_paypoint_test_status'] = array(
    '#type' => 'select',
    '#title' => t('Test status'),
    '#description' => t('"Test" mode will simulate an authorised callback without contacting the bank, 
      "Auto-decline" will simulate a declined callback without contacting the bank, and "Live" will send the transaction 
      to the bank for authorization.'),
    '#options' => array(
      'true' => t('Test'),
      'false' => t('Auto-decline'),
      'live' => t('Live')
    ),
    '#default_value' => variable_get('uc_paypoint_test_status', 'true'),
  );
  $form['uc_paypoint_deferred_transactions'] = array(
    '#type' => 'select',
    '#title' => t('Deferred payments'),
    '#description' => t('Deferred transactions are useful if you want to take orders for items that you cannot always 
      guarantee will be in stock. Using deferred transactions, you can take an initial authorisation 
        (at which point no money has actually been taken) and then when your product arrives in stock you can release 
        the funds for the deferred transaction and then ship the product out to your customer. <ul><li>"Defer" will 
        authorise only one unit of currency. This is useful for avoiding tying up funds in your customer\'s account 
        if all you want to do is "get their details into the system".</li><li>"Full" will authorise the full amount of the
        transaction and freeze the funds in the customer\'s account. A new authorisation takes place when funds are 
        released so be careful not to ship goods before confirming release of funds.</li><li>"Reuse" will authorise 
        the full amount of the initial transaction but on release will use the original authorisation code 
        (which was obtained by the initial deferred transaction - if it is still valid.) 
        If not still valid, releasing will cause a new authorisation to take place (as is the casewith "Defer" and "Full").</li></ul>'),
    '#options' => array(
      'false' => t('Disabled'),
      'true' => t('Defer'),
      'full' => t('Full'),
      'reuse' => t('Reuse'),
    ),
    '#default_value' => variable_get('uc_paypoint_deferred_transactions', 0),
  );
  $form['uc_paypoint_reuse_credit_days'] = array(
    '#type' => 'select',
    '#title' => t('Credit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('The number of days within which a credit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => variable_get('uc_paypoint_reuse_credit_days', 7),
  );
  $form['uc_paypoint_reuse_debit_days'] = array(
    '#type' => 'select',
    '#title' => t('Debit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('The number of days within which a debit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => variable_get('uc_paypoint_reuse_debit_days', 1),
  );
  $form['uc_paypoint_require_cv2'] = array(
    '#type' => 'checkbox',
    '#title' => t('Require CV2'),
    '#default_value' => variable_get('uc_paypoint_require_cv2', 1),
  );
  $form['uc_paypoint_default_cv2avs'] = array(
    '#type' => 'select',
    '#title' => t('Default cv2avs value'),
    '#multiple' => FALSE,
    '#description' => t("This is the value for the cv2avs callback parameter returned by PayPoint's 
      server when running in test mode."),
    '#options' => _uc_paypoint_get_cv2avs_options(),
    '#default_value' => variable_get('uc_paypoint_default_cv2avs', 'ALL MATCH'),
  );
  $form['uc_paypoint_send_billing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send billing information to PayPoint'),
    '#default_value' => variable_get('uc_paypoint_send_billing', 1),
  );
  $form['uc_paypoint_duplicate_billing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send billing information as shipping information to PayPoint'),
    '#default_value' => variable_get('uc_paypoint_duplicate_billing', 0),
    '#description' => t('Enable this to copy the billing details and send them to PayPoint as shipping details.'),
  );
  $form['uc_paypoint_send_shipping'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send shipping information to PayPoint'),
    '#default_value' => variable_get('uc_paypoint_send_shipping', 1),
    '#description' => t('Enabling this will override \'Send billing information as shipping information to PayPoint\''),
  );
  $form['uc_paypoint_send_email'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send email address to PayPoint'),
    '#default_value' => variable_get('uc_paypoint_send_email', 1),
    '#description' => t('When sending the email address to PayPoint, PayPoint will send a payment confirmation email 
      to the customer.'),
  );
  $form['uc_paypoint_attach_merchant'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send order to merchant as an attachment'),
    '#default_value' => variable_get('uc_paypoint_attach_merchant', 1),
  );
  $form['uc_paypoint_attach_customer'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send order to customer as an attachment'),
    '#default_value' => variable_get('uc_paypoint_attach_customer', 1),
  );
  $form['uc_paypoint_duplicate_checking'] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable duplicate checking'),
    '#description' => t('This will turn off duplicate checking on the PayPoint server. Only useful for testing.'),
    '#default_value' => variable_get('uc_paypoint_duplicate_checking', 0),
  );
  $form['uc_paypoint_debug'] = array(
    '#type' => 'select',
    '#title' => t('Debug mode'),
    '#description' => t("Select the debug mode. 'Log' will log debug info to watchdog and 'Full' will interrupt 
      the checkout process and print debug info to the screen."),
    '#multiple' => FALSE,
    '#options' => array(
      'off' => 'Off',
      'log' => 'Log',
      'full' => 'Full',
      ),
    '#default_value' => variable_get('uc_paypoint_debug', 'off'),
  );
  return $form;
}

/**
 * Implementation of hook_form_alter().
 */
function uc_paypoint_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'uc_cart_checkout_form') {
    // Clear out the session variables.
    
    // Cache the CC details for use in other functions.
    if (isset($_SESSION['paypoint_crd'])) {
      uc_credit_cache('save', $_SESSION['paypoint_crd']);

      // Store the encrypted details to the form for processing on submit, used in cart-process.
      $form['payment_details_data'] = array(
        '#type' => 'hidden',
        '#value' => $_SESSION['paypoint_crd'],
      );
    }
  }

  if ($form_id == 'uc_cart_checkout_review_form') {
    // Check if the customer paid by CC and refreshed on the review page.
    if (isset($_SESSION['uc_paypoint_cc_pay']) && !isset($_SESSION['paypoint_crd']) && empty($_POST['paypoint_crd'])) {
      // Send them back to the checkout form to put in their details again.
      drupal_set_message(t('To protect our customers from identity theft, credit card details are erased when a browser refreshes on the checkout review page. Please enter your card details again and re-submit the form.'), 'error');

      $_SESSION['uc_paypoint_clear_details'] = TRUE;
      unset($_SESSION['uc_paypoint_cc_pay']);
      drupal_goto('cart/checkout');
    }

    // Cache the CC details for use in other functions.
    uc_credit_cache('save', $_SESSION['paypoint_crd']);

    // Store the encrypted details to the form for processing on submit.
    // For some reason submit does not trigger if a) this is a value field, b) this value is set as a #something = value.
    $form['paypoint_crd'] = array(
      '#type' => 'hidden',
      '#value' => base64_encode($_SESSION['paypoint_crd']),
    );

    // Add submit handler to preserve CC details for the back button and
    // failed order submissions.
    $form['back']['#submit'][] = 'uc_paypoint_cart_review_back_submit';

    // Reconstruct the submit handler array for before and after processing.
    $submit = array_merge(array('uc_paypoint_cart_review_pre_form_submit'), $form['#submit']);
    $submit[] = 'uc_paypoint_cart_review_post_form_submit';

    $form['#submit'] = $submit;
    // Clear the session of the details.
    unset($_SESSION['paypoint_crd']);
  }
}

/**
 * Submit handler that caches encrypted CC data on the review form for processing.
 */
function uc_paypoint_cart_review_back_submit($form, &$form_state) {
  $session_card_data = base64_decode($_POST['paypoint_crd']);
  $_SESSION['paypoint_crd'] = $session_card_data;
  uc_credit_cache('save', $session_card_data);
}

/**
 * Submit handler triggered first when the review form is submitted.
 */
function uc_paypoint_cart_review_pre_form_submit($form, &$form_state) {
  $session_card_data = base64_decode($_POST['paypoint_crd']);
  $_SESSION['paypoint_crd'] = $session_card_data;
  uc_credit_cache('save', $session_card_data);
}

/**
 * Submit handler triggered at the end of the review form submit chain.
 */
function uc_paypoint_cart_review_post_form_submit($form, &$form_state) {
  if ($_SESSION['do_complete']) {
    // Otherwise stuff it back in the session for the next pageload.
    unset($_SESSION['paypoint_crd']);
  }
}

/**
 * Implementing hook_order().
 *
 * We hook into the order submission, passing calling paypoint and into load
 * in order to get credit card details back from cache.
 */
function uc_paypoint_order($op, &$order, $arg2) {
  switch ($op) {
    case 'submit': // User submitted the order after checkout review.
      $key = uc_credit_encryption_key();
      $crypt = new uc_encryption_class;
      $order->payment_details = unserialize($crypt->decrypt($key, $_SESSION['paypoint_crd']));
      $results = uc_paypoint_xmlrpc_request($order);
      return uc_paypoint_complete_request($results);
    case 'load':
      if ($order->payment_method == 'paypoint') {
        // Load the CC details from the credit cache if available.
        $order->payment_details = uc_credit_cache('load');
      }
      break;
  }
}


/**
 * Submit an order to PayPoint via XML-RPC
 */
function uc_paypoint_xmlrpc_request($order) {
  $data = uc_paypoint_get_data($order);
  $parameters = _uc_paypoint_create_parameters($data);
  uc_paypoint_debug($parameters, $order);

  $request = array();
  $request[] = 'https://www.secpay.com/secxmlrpc/make_call';
  $request[] = 'SECVPN.validateCardFull';
  $request = array_merge($request, $parameters);

  // We call this way because of the large number of arguments.
  $result = call_user_func_array('xmlrpc', $request);

  if (empty($result)) { // Something went wrong with the remote call.
    $error = xmlrpc_error();
    if ($error->is_error) {
      watchdog('PayPoint', 'XML-RPC error: @error, message: @message.', array('@error' => $error->code, '@message' => $error->message));
    }
  }

  $results = array();
  // Cut off the leading ? and parse the returned query string into a neat array.
  parse_str(drupal_substr($result, 1), $results);
  return $results;
}

/**
 * Complete a sale based on the results of the xml-rpc request.
 */
function uc_paypoint_complete_request($results) {
  $response_message = _uc_paypoint_authorisation_code($results);
  global $user; // We no longer get the uid as a return query parameter. TOOD?

  if ($results['trans_id']) {
    $order = uc_order_load($results['trans_id']);
    if ($order->payment_method != 'paypoint' && uc_order_status_data($order->order_status, 'state') != 'in_checkout') {
      drupal_set_message(t('We were unable to process your payment. Please verify your details and try again. If the problem persists, please contact us. Many thanks. !email', array('!email' => _uc_paypoint_store_email())), 'error');
      watchdog('PayPoint', 'PayPoint order attempted for @trans_id.', array('@trans_id' => $results['trans_id']), WATCHDOG_WARNING);
      $status = FALSE;
    }
    else {
      watchdog('PayPoint', 'Remote call results received for order @order_id.', array('@order_id' => $order->order_id), WATCHDOG_NOTICE,
        l(t('Order @order_id', array('@order_id' => $order->order_id)), 'admin/store/orders/' . $user->uid . '/' . $order->order_id));
     }
   }
  // If the trans_id is not set we assume there was an error and abort processing.
  else {
    if (isset($results['message'])) {
      drupal_set_message(t('Error message: @message', array('@message' => $results['message'])), 'error');
    }
    $status = FALSE;
  }

  // Handle the return code.
  switch ($results['code']) {
    case 'A': // Transaction authorised, we accept and process the payment on our end and live happily ever after.
      $comment = t('Order successfully processed by PayPoint for order #@order.', array('@order' => $order->order_id));
      $message = t('Order successfully processed.');
      uc_payment_enter($order->order_id, 'paypoint', $results['amount'], empty($results['uid']) ? 0 : $results['uid'], NULL, $comment);
      $status = TRUE;
      break;

    case 'N': // Payment not authorised by the bank.
      drupal_set_message(t('The transaction was not authorised by the bank. Please contact us to complete your order !email', array('!email' => _uc_paypoint_store_email())), 'error');
      $response_code = _uc_paypoint_response_code($results['resp_code']);
      $message = $response_message . $response_code;
      $status = FALSE;
      break;

    case 'C': // Communication error.
    default:
      drupal_set_message(t('A communication error occurred. Please try again later or contact us to complete your order !email', array('!email' => _uc_paypoint_store_email())), 'error');
      $message = t('Communication error');
      $status = FALSE;
      break;

    case 'P:A': case 'P:X': case 'P:P': case 'P:S': case 'P:E': case 'P:I':
    case 'P:C': case 'P:T': case 'P:N': case 'P:M': case 'P:B': case 'P:D':
    case 'P:V': case 'P:R': case 'P:#': // Pre-bank checks failed.
      drupal_set_message(t('The details of the order are not sufficient to complete the transaction and we were unable to process your
       payment. Please verify your details and try again. If the problem persists, please contact us. Many thanks. !email', array('!email' => _uc_paypoint_store_email())), 'error');
     $message = t('Pre-bank check failed.');
     $status = FALSE;
  }

  $message .= ' ' . _uc_paypoint_authorisation_code($results);
  watchdog('PayPoint', $message, array(), WATCHDOG_NOTICE);

  if (!$status) {
    $message = variable_get('uc_credit_fail_message', t('We were unable to process your credit card payment. Please verify your card details and try again.  If the problem persists, contact us to complete your order.'));
  }

  uc_paypoint_debug($results, $order);
  return array(array('pass' => $status, 'message' => $message));
}


/**
 * Display the credit card details form on the checkout screen.
 *
 * This form has been forked from uc_credit, removed the possibility to
 * configure form fields, since PayPoint expects them anyway.
 */
function uc_paypoint_credit_form($form_state = array(), $order = NULL) {
  // Normally the CC data is posted in via AJAX.
  if (!empty($_POST['payment-details-data']) && arg(0) == 'cart') {
    $order->payment_details = uc_credit_cache('save', $_POST['payment-details-data']);
  }

  // But we have to accommodate failed checkout form validation here.
  if (isset($_SESSION['paypoint_crd'])) {
    $order->payment_details = uc_credit_cache('save', $_SESSION['paypoint_crd']);
    unset($_SESSION['paypoint_crd']);
  }

  $form['cc_policy'] = array('#value' => variable_get('uc_credit_policy', t('Your billing information must match the billing address for the credit card entered below or we will be unable to process your payment.')));

  $allowed_cards = variable_get('uc_paypoint_credit_cards', array_keys(_uc_paypoint_credit_cards()));
  foreach ($allowed_cards as $card_id => $card_name) {
    if ($card_name) {
      $options[$card_id] = $card_name;
    }
  }

  $form['cc_type'] = array(
    '#type' => 'select',
    '#title' => t('Card type'),
    '#options' => $options,
    '#default_value' => $order->payment_details['cc_type'] ? $order->payment_details['cc_type'] : array_shift(array_keys($options)),
  );

  $form['cc_owner'] = array(
    '#type' => 'textfield',
    '#title' => t('Card owner'),
    '#default_value' => $order->payment_details['cc_owner'],
    '#attributes' => array('autocomplete' => 'off'),
    '#size' => 32,
    '#maxlength' => 64,
  );

  // Set up the default CC number on the credit card form.
  if (variable_get('uc_credit_validate_numbers', TRUE) && (strlen($order->payment_details['cc_number']) > 4 && !_valid_card_number($order->payment_details['cc_number']))) {
    // Display the number as is if it does not validate so it can be corrected.
    $default_num = $order->payment_details['cc_number'];
  }
  elseif (!empty($order->payment_details['cc_number'])) {
    if (user_access('view cc numbers') && strlen($order->payment_details['cc_number']) > 4) {
      // Display the full number to those with access.
      $default_num = $order->payment_details['cc_number'];
    }
    else {
      // Otherwise default to the last 4 digits.
      $default_num = t('(Last 4) ') . substr($order->payment_details['cc_number'], -4);
    }
  }
  $form['cc_number'] = array(
    '#type' => 'textfield',
    '#title' => t('Card number'),
    '#default_value' => $_SESSION['uc_paypoint_clear_details'] ? '' : $default_num,
    '#attributes' => array('autocomplete' => 'off'),
    '#size' => 20,
    '#maxlength' => 19,
  );

  $form['cc_start_month'] = uc_select_month(t('Start Month'), $order->payment_details['cc_start_month'], TRUE);
  $form['cc_start_year'] = uc_select_year(t('Start Year'), $order->payment_details['cc_start_year'], date('Y') - 10, date('Y'), TRUE);

  $form['cc_exp_month'] = uc_select_month(t('Expiration Month'), $order->payment_details['cc_exp_month']);
  $form['cc_exp_year'] = uc_select_year(t('Expiration Year'), $order->payment_details['cc_exp_year']);

  // Set up the default Issue Number on the credit card form.
  if (!_valid_card_issue($order->payment_details['cc_issue'])) {
    // Display the Issue Number as is if it does not validate so it can be corrected.
    $default_card_issue = $order->payment_details['cc_issue'];
  }
  elseif (!empty($order->payment_details['cc_issue'])) {
    if (user_access('view cc numbers')) {
      // Display the full number to those with access.
      $default_card_issue = $order->payment_details['cc_issue'];
    }
    else {
      // Otherwise mask it with dashes.
      $default_card_issue = str_repeat('-', strlen($order->payment_details['cc_issue']));
    }
  }
  $form['cc_issue'] = array(
    '#type' => 'textfield',
    '#title' => t('Issue Number'),
    '#default_value' => $default_card_issue,
    '#attributes' => array('autocomplete' => 'off'),
    '#size' => 2,
    '#maxlength' => 2,
  );

  // Set up the default CVV  on the credit card form.
  if (!_valid_cvv($order->payment_details['cc_cvv'])) {
    // Display the CVV as is if it does not validate so it can be corrected.
    $default_cvv = $order->payment_details['cc_cvv'];
  }
  elseif (!empty($order->payment_details['cc_cvv'])) {
    if (user_access('view paypoint credit card numbers')) {
      // Display the full number to those with access.
      $default_cvv = $order->payment_details['cc_cvv'];
    }
    else {
      // Otherwise mask it with dashes.
      $default_cvv = str_repeat('-', strlen($order->payment_details['cc_cvv']));
    }
  }
  $form['cc_cvv'] = array(
    '#type' => 'textfield',
    '#title' => t('CVV'),
    '#default_value' => $_SESSION['uc_paypoint_clear_details'] ? '' : $default_cvv,
    '#attributes' => array('autocomplete' => 'off'),
    '#size' => variable_get('uc_credit_amex', TRUE) ? 4 : 3,
    '#maxlength' => variable_get('uc_credit_amex', TRUE) ? 4 : 3,
  );

  unset($_SESSION['uc_paypoint_clear_details']);

  return $form;
}

function _uc_paypoint_cv2avs_message($code) {
  switch ($code) {
    case 'ALL MATCH':
      return t('All the data provided matched that which the card issuer had on record.');
    case 'SECURITY CODE MATCH ONLY':
      return t('Only the security code matched.');
    case 'ADDRESS MATCH ONLY':
      return t('Only the address matched.');
    case 'NO DATA MATCHES':
      return t('None of the data matched.');
    case 'DATA NOT CHECKED':
      return t('The cv2avs system is unavailable or not supported by this card issuer.');
    case 'PARTIAL ADDRESS MATCH / POSTCODE':
      return t('The postcode matched but the address did not.');
    case 'PARTIAL ADDRESS MATCH / ADDRESS':
      return t('The address matched but the postcode did not.');
    case 'SECURITY CODE MATCH / POSTCODE':
      return t('The security code and postcodes matched but the address did not');
    case 'SECURITY CODE MATCH / ADDRESS':
      return t('The security code and address matched but the postcode did not.');
    default:
      return t('Unkown error');
  }
}

function _uc_paypoint_get_cv2avs_options() {
  return drupal_map_assoc(array(
    'ALL MATCH',
    'SECURITY CODE MATCH ONLY',
    'ADDRESS MATCH ONLY',
    'NO DATA MATCHES',
    'DATA NOT CHECKED',
    'PARTIAL ADDRESS MATCH / POSTCODE',
    'PARTIAL ADDRESS MATCH / ADDRESS',
    'SECURITY CODE MATCH / POSTCODE',
    'SECURITY CODE MATCH / ADDRESS',
  ));
}

/**
 * This parameter is only returned when a transaction is declined and code = N.
 * It is a failure code sent from the bank and should *not* be displayed to the
 * cardholder.
 */
function _uc_paypoint_response_code($code) {
  if (is_numeric($code)) {
    switch ($code) {
      case 2:
      case 83:
        return t('Referral. It may be possible to obtain an authorisation code from the bank over the phone.');
      case 5:
      case 54:
        return t('Not authorised by the bank.');
      case 30:
      default:
        return t('General error (retry after 1 minute may succeed, depending on the error).');
    }
  }
}

function _uc_paypoint_authorisation_code($parameters) {
  switch ($parameters['code']) {
    case "A":
      return t('Transaction authorised by bank. Authorisation code @auth_code available as bank reference.',  array('@auth_code' => $parameters['auth_code']));
    case "N":
      return t('Transaction not authorised.');
    case "C":
      return t('Communication problem. Trying again later may well work');
    case "P:A":
      return t('Pre-bank checks. Amount not supplied or invalid.');
    case "P:X":
      return t('Pre-bank checks. Not all mandatory parameters supplied.');
    case "P:P":
      return t('Pre-bank checks. Same payment presented twice.');
    case "P:S":
      return t('Pre-bank checks. Start date invalid.');
    case "P:E":
      return t('Pre-bank checks. Expiry date invalid.');
    case "P:I":
      return t('Pre-bank checks. Issue number invalid.');
    case "P:C":
      return t('Pre-bank checks. Card number fails LUHN check.');
    case "P:T":
      return t('Pre-bank checks. Card type invalid - i.e. does not match card number prefix.');
    case "P:N":
      return t('Pre-bank checks. Customer name not supplied.');
    case "P:M":
      return t('Pre-bank checks. Merchant does not exist or not registered yet.');
    case "P:B":
      return t('Pre-bank checks. Merchant account for card type does not exist.');
    case "P:D":
      return t('Pre-bank checks. Merchant account for this currency does not exist.');
    case "P:V":
      return t('Pre-bank checks. CV2 security code mandatory and not supplied / invalid.');
    case "P:R":
      return t('Pre-bank checks. Transaction timed out awaiting a virtual circuit. Merchant may not have enough virtual circuits for the volume of business.');
    case "P:#":
      return t('Pre-bank checks. No MD5 hash / token key set up against account.');
  }
}

function uc_paypoint_debug($parameters, $order = NULL) {
  $debug_mode = variable_get('uc_paypoint_debug', 'off');
  // In some cases $order will not be populated, often this is due to connection error to the remote server.

  $debug = isset($order) ?
    t('Debugging order @order_id, PayPoint result: <pre>@vars</pre>', array('@order_id' => $order->order_id, '@vars' => print_r($parameters, TRUE))) :
    t('Debugging order not created, PayPoint result: <pre>@vars</pre>', array('@vars' => print_r($parameters, TRUE)));

  switch ($debug_mode) {
    case 'full':
      $output .= $debug;
      // Fallthrough
    case 'log':
      watchdog('PayPoint', $debug);
      break;
    case 'off': default:
      continue;
      break;
  }

  return $output;
}

function _uc_paypoint_boolean_to_string($input) {
  return ($input) ? 'true' : 'false';
}

/**
 * Helper function to render the store email address through l().
 *
 * @return The rendered HTML.
 */
function _uc_paypoint_store_email() {
  $store_mail = variable_get('uc_store_email', '');
  return l($store_mail, 'mailto:' . $store_mail, array('absolute' => TRUE));
}

/**
 * Assembling a Paypoint friendly structure of data to pass on as call parameters.
 *
 * Data can be passed as either a string, with comma separated key=value pairs, or in XML format. 
 * The usage of XML format is not clear from documentation, therefore used only where it is explicitly mentioned.
 * The building of the data array is split into sections based on the API requirements.
 */
function uc_paypoint_get_data($order) {
  // Handling the first coupel of single parameters: 
  // mid, trans_id, vpn_pswd, ip, name, card_number, amount, expiry_date, issue_number, start_date.
  // We must format the year and month to format the service expects (mmyy).
  $expiry_date = date('my', mktime(0, 0, 0, $order->payment_details['cc_exp_month'], 1, $order->payment_details['cc_exp_year']));
  if (!empty($order->payment_details['cc_start_month'])) {
    $start_date = date('my', mktime(0, 0, 0, $order->payment_details['cc_start_month'], 1, $order->payment_details['cc_start_year']));
  }

  $data = array(
    'mid' => variable_get('uc_paypoint_merchant', 'secpay'),
    'trans_id' => $order->order_id,
    'vpn_pswd' => variable_get('uc_paypoint_vpn', 'secpay'),
    'ip' => $_SERVER['REMOTE_ADDR'],
    'name' => $order->payment_details['cc_owner'],
    'card_number' => $order->payment_details['cc_number'],
    'amount' => uc_currency_format($order->order_total, FALSE, FALSE, '.'),
    'expiry_date' => $expiry_date,
    'issue_number' => $order->payment_details['cc_issue'],
    'start_date' => $start_date,
  );

  // Order details XML.
  if (variable_get('uc_paypoint_attach_merchant', 1)) {
    $xml_order = "<order class='com.secpay.seccard.Order'><orderLines class='com.secpay.seccard.OrderLine'>";
    foreach ($order->products as $product) {
      $xml_order .= "<OrderLine><prod_code>$product->title ($product->model) ";
      if (!empty($product->data['attributes'])) {
        foreach ($product->data['attributes'] as $attribute => $selection) {
          $xml_order .= " - $attribute: $selection[0],";
        }
      }
      $xml_order .= "</prod_code><item_amount>$product->price</item_amount><quantity>$product->qty</quantity></OrderLine>";
    }
    $comments = uc_order_comments_load($order->order_id);
    if (is_array($comments)) {
      $xml_order .= '<OrderLine><prod_code>COMMENTS - ' . $comments[0]->message . '</prod_code></OrderLine>';
    }
    foreach ($order->line_items as $line_item) {
      switch ($line_item['type']) {
        case 'shipping':
          $title = 'SHIPPING';
          break;
        case 'uc_discounts':
          $title = 'DISCOUNT';
          break;
        default:
          $title = NULL;
          break;
      }
      if (!is_null($title)) {
        $xml_order .= "<OrderLine><prod_code>$title</prod_code><item_amount>" . abs($line_item['amount']) . '</item_amount></OrderLine>';
      }
    }
    $xml_order .= '</orderLines></order>';
    $data['order'] = $xml_order;
  }
  else {
    $data['order'] = '';
  }

  // Billing XML
  if (variable_get('uc_paypoint_send_billing', 1)) {
    $billing = array(
      'name' => $order->billing_first_name .' '. $order->billing_last_name,
      'company' => $order->billing_company,
      'addr_1' => $order->billing_street1,
      'addr_2' => $order->billing_street2,
      'city' => $order->billing_city,
      'post_code' => $order->billing_postal_code,
      'tel' => $order->billing_phone,
    );

    if (variable_get('uc_paypoint_send_email', 1)) {
      $billing['bill_email'] = $order->primary_email;
    }

    $data['billing'] = '<billing class="com.secpay.seccard.Address">';
    foreach ($billing as $key => $value) {
      if (!empty($value)) {
        $data['billing'] .= "<$key>$value</$key>";
      }
    }
    $data['billing'] .= '</billing>';
  }
  else {
    $data['billing'] = '';
  }

  // Shipping details
  if (variable_get('uc_paypoint_send_shipping', 1)) {
    $shipping = array(
      'name'      => $order->shipping_first_name .' '. $order->shipping_last_name,
      'company'   => $order->shipping_company,
      'addr_1'    => $order->shipping_street1,
      'addr_2'    => $order->shipping_street2,
      'city'      => $order->shipping_city,
      'post_code' => $order->shipping_postal_code,
      'tel'       => $order->shipping_phone,
    );

    $data['shipping'] = _uc_paypoint_prepare_list($shipping);
  }
  elseif (variable_get('uc_paypoint_duplicate_billing', 0)) {
    $data['shipping'] = $data['billing'];
  }
  else {
    $data['shipping'] = '';
  }

  // Options
  $options = array(
    'dups' => (variable_get('uc_paypoint_duplicate_checking', 0) === 1) ? 'false' : 'true',
    'test_status' => variable_get('uc_paypoint_test_status', 'true'),
    'deferred' => variable_get('uc_paypoint_deferred_transactions', 'false'),
    'card_type' => $order->payment_details['cc_type'],
    'cv2' => $order->payment_details['cc_cvv'],
    'currency' => variable_get('uc_paypoint_currency', 'GBP'),
  );

  if (variable_get('uc_paypoint_test_status', 'true') == 'true') {
    $options['default_cv2avs'] = variable_get('uc_paypoint_default_cv2avs', 'ALL MATCH');
  }
  if (variable_get('uc_paypoint_require_cv2', 1)) {
    $options['req_cv2'] = 'true';
  }
  
  $data['options'] = _uc_paypoint_prepare_list($options);
  return $data;
}

/**
 * Helper function to prepare a comma separated list of keys = values.
 */
function _uc_paypoint_prepare_list($data) {
  $list = array();
  foreach ($data as $key => $value) {
    $trimmed = trim($value);
    if (!empty($trimmed)) {
      $list[] = "$key=$value";
    }
  }
  return implode(',', $list);
}

/**
 * Create the parameters array for the XML-RPC call.
 */
function _uc_paypoint_create_parameters($data) {
  $parameters = array();
  $parameters[] = $data['mid']; // 0 - Merchant id, mid
  $parameters[] = $data['vpn_pswd']; // 1 - VPN password
  $parameters[] = $data['trans_id']; // 2 - Transaction id, trans_id
  $parameters[] = $data['ip']; // 3 - External IP address of the cardholder.
  $parameters[] = $data['name']; // 4 - Cardholder name
  $parameters[] = $data['card_number']; // 5 - Card number
  $parameters[] = $data['amount']; // 6 - Amount
  $parameters[] = $data['expiry_date']; // 7 - Expiration date, formatted as mm/yy or mmyy
  $parameters[] = $data['issue_number']; // 8 - Issue
  $parameters[] = $data['start_date']; // 9 - Start date
  $parameters[] = $data['order']; // 10 - Order.
  $parameters[] = $data['shipping']; // 11 - Shipping address.
  $parameters[] = $data['billing']; // 12 - Billing address.
  $parameters[] = $data['options']; // 13 - Extra options.
  return $parameters;
}

function _uc_paypoint_order_empty($order = NULL) {
  if (empty($order)) {
    return TRUE;
  }
  $total = ($order->order_total == 0);
  $billing = 
    empty($order->billing_first_name) ||
    empty($order->billing_last_name) ||
    empty($order->billing_street1) ||
    empty($order->billing_city) ||
    empty($order->billing_postal_code);
  $delivery = 
    empty($order->delivery_first_name) ||
    empty($order->delivery_last_name) ||
    empty($order->delivery_street1) ||
    empty($order->delivery_city) ||
    empty($order->delivery_postal_code);
  return $total || $billing || $delivery;
}

/**
 * Return a list of credit cards PayPoint can process.
 */
function _uc_paypoint_credit_cards() {
  return array(
    'Visa' => t('Visa'),
    'Master Card' => t('Master Card'),
    'Maestro' => t('Maestro'),
    'Solo' => t('Solo'),
    'Delta' => t('Visa Debit, Connect, Electron'),
    'American Express' => t('American Express'),
    'Diners Club' => t('Diners Club'),
    'JCB' => t('Japanese Credit Card'),
    'Laser' => t('Laser'),
  );
}

/**
 * Returns an array of options for the currency selection widget.
 */
function _uc_paypoint_currency_codes() {
  return drupal_map_assoc(array('AUD', 'CAD', 'EUR', 'GBP', 'HKD', 'JPY', 'USD'));
}
